# OmniBridge

[![CI](https://github.com/chuanjin/OmniBridge/actions/workflows/ci.yml/badge.svg)](https://github.com/chuanjin/OmniBridge/actions/workflows/ci.yml)
[![Go Version](https://img.shields.io/badge/Go-1.25%2B-00ADD8?logo=go)](https://go.dev/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](./LICENSE)

**OmniBridge is an AI-native binary protocol gateway**: it parses known protocols at high speed and **learns unknown ones automatically** using an LLM, then persists the learned parser for future traffic.

> If your data streams are evolving faster than hand-written decoders, OmniBridge gives you a practical way to keep up.

---

- âš¡ **Fast path first**: Known signatures route directly to existing parsers via a **Trie-based dispatcher**.
- ğŸ§  **AI discovery mode**: Unknown packets trigger LLM-assisted parser generation with **Zero-Config Signature Detection**.
- ğŸ” **Self-healing parsers**: If a learned parser fails at runtime, OmniBridge attempts automatic repair by consulting the LLM with the error context.
- ğŸ’¾ **Persistent learning**: Generated parsers are cached in-memory and saved in `./storage` for persistence.
- ğŸ”Œ **Provider flexibility**: Works with **Gemini** (cloud) and **Ollama** (local).
- ğŸ§ª **Execution Safety**: Dynamic parsers run with **50ms timeout protection** and panic recovery to ensure system stability.

---

1. **Ingest**: Raw bytes are received from simulation or TCP server modes.
2. **Dispatch**: Using a **Trie (Prefix Tree)**, the system performs a longest-prefix match on the incoming data to identify the protocol.
3. **Parse**: If a parser exists, it is executed within the **Dynamic Engine**.
4. **Discover**: On a cache miss, the AI identifies the signature and generates a Go `Parse` function.
5. **Cache + Persist**: The new parser is compiled (via `yaegi`), cached for performance, and saved to disk.
6. **Repair**: If a parser throws a runtime error, the **Self-Healing Loop** triggers an AI-assisted fix.

---

## ğŸš€ Quick Start

### 1) Prerequisites

- Go **1.25+**
- One LLM provider:
  - **Gemini**: set `GEMINI_API_KEY`
  - **Ollama**: local Ollama server running

### 2) Install

```bash
git clone https://github.com/chuanjin/OmniBridge.git
cd OmniBridge
go mod tidy
```

### 3) Configure environment

Create a `.env` file:

```env
# Needed only for Gemini provider
GEMINI_API_KEY=your_api_key_here
```

### 4) Run in simulation mode (default)

```bash
go run cmd/server/main.go --provider gemini --model gemini-2.0-flash
```

Run with Ollama:

```bash
go run cmd/server/main.go --provider ollama --model deepseek-coder:1.3b
```

### 5) Run as TCP gateway

```bash
go run cmd/server/main.go --mode server --addr :8080 --provider gemini --model gemini-2.0-flash
```

Send binary data to it from your client; OmniBridge will parse known signatures and discover unknown ones.

---

## ğŸ³ Docker

Build and run:

```bash
docker build -t omnibridge .
docker run --rm -p 8080:8080 --env GEMINI_API_KEY=$GEMINI_API_KEY omnibridge
```

---

## ğŸ“ Project layout

- `cmd/server/` â€” CLI entrypoint (simulation + TCP server modes)
- `internal/parser/` â€” dispatcher, discovery service, parser manager, dynamic engine
- `internal/logger/` â€” structured logging setup
- `agents/` â€” system prompt(s) used for parser generation
- `seeds/` â€” built-in parser seeds loaded at startup
- `examples/` â€” sample protocol data
- `storage/` â€” learned parsers + manifest (created at runtime)

---

## ğŸ› ï¸ Internal Mechanics

### Trie Dispatcher
OmniBridge uses a Prefix Tree (Trie) to manage protocol signatures. This enables efficient routing even with variable-length signatures, ensuring the **longest match** is always prioritized.

### Dynamic Engine & Caching
Parsers are implemented as Go code generated by AI. To ensure high performance:
- **JIT Compilation**: Code is compiled at runtime using the `yaegi` interpreter.
- **Concurrent Caching**: Compiled functions are cached in a thread-safe map, avoiding redundant compilation overhead for future packets.

### Execution Safety
Running AI-generated code requires guardrails. OmniBridge provides:
- **Timeout Protection**: Every parser execution is capped at 50ms.
- **Panic Recovery**: The system traps runtime panics (e.g., out-of-bounds access) and routes them to the repair cycle.
- **Restricted Stdlib**: Parsers only have access to safe packages like `encoding/binary`, `math`, and `bytes`.

---

## ğŸ§­ Project Roadmap

OmniBridge is actively evolving. High-priority areas include:

- **Enhanced Observability**: Exporting metrics via Prometheus/OpenTelemetry.
- **Hardened Validation**: Pre-execution static analysis of AI-generated code.
- **Stateful Protocols**: Support for protocols requiring sequence tracking or multi-packet assembly.

---

## ğŸ§ª MCP Integration

OmniBridge can run as an **MCP Server** (Model Context Protocol), exposing its protocol discovery and parsing capabilities to AI applications and agents.

### Running as MCP Server

```bash
go run cmd/server/main.go --mode mcp --provider gemini --model gemini-2.0-flash
```

### Available Resources

- `protocol://list` - List all known protocols with signatures
- `protocol://manifest` - Complete manifest mapping

### Available Tools

- `parse_binary` - Parse hex-encoded binary data
- `discover_protocol` - Trigger AI-based protocol discovery
- `list_protocols` - List all available protocols

### Available Prompts

- `protocol_discovery` - Template for discovering new protocols
- `parser_repair` - Template for fixing broken parsers

### Example MCP Client Configuration (Claude Desktop)

```json
{
  "mcpServers": {
    "omnibridge": {
      "command": "go",
      "args": ["run", "/path/to/OmniBridge/cmd/server/main.go", "--mode", "mcp", "--provider", "gemini"]
    }
  }
}
```

---

## ğŸ¤ Contributing

Issues and PRs are welcome. If you have a target protocol family (CAN, telemetry, industrial buses, custom IoT frames), open an issue with sample payloads and expected fields.

---

## ğŸ“œ License

MIT â€” see [`LICENSE`](./LICENSE).
